参考网址：https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst

启动优化：
通常第一件事情就是启动优化。Swift提供了三种不同的优化级别：

☀ -Onone: 这个意味着正常的开发。这个级别执行最小的优化和保存所有的debug信息。
☀︎ -O:这个意味着对于大多数生产代码。编译器积极的进行优化，大大改善提交代码的类型和数量。debug信息会被提交但是会有所省略。   
☀ -Ounchecked: 这是一个特殊的优化模式，对于一些特定的库或者是应用是用安全性来换取性能。编译器会移除所有的溢出检测和一些隐式的类型检查。
这不是在通常情况下使用的，因为它可能会导致内存安全问题和整数溢出。如果你想这样做的话，必须仔细审查你的代码对整数溢出和类型转换来说是安全的。

整体组件优化：
默认情况下，Swift单独编译每个文件。这能让Xcode非常快速的并行编译多个文件。然而，每个文件单独编译的话会阻止某些编译器的优化。
Swift在即使它是一个单独的文件或是一个单独的单元也能够对这个程序进行编译。
这个模式可以是用命令行flag -whole-module-optimization来开启。在这种模式下被编译的程序最有可能需要更长的时间来编译，但是运行起来会更快。

这个模式能够通过Xcode中的build setting ‘Whole Module Optimization’来启用。

减少动态调度
Swift在默认情况下就像OC那样是非常动态语言。与OC不同的是，Swift能够让程序员在必要时候有能力去移除或减少这种动态机制从而提升运行时的性能。
以下是几个示例：

动态调度
默认情况下类使用动态调度方法和属性。因此下面的代码片段中，a.aProperty,a.doSomething,a.doSomethingElse方法都是通过动态调度来调用的。
class A {
  var aProperty: [Int]
  func doSomething() { ... }
  dynamic doSomethingElse() { ... }
}

class B : A {
  override var aProperty {
    get { ... }
    set { ... }
  }

  override func doSomething() { ... }
}

func usingAnA(a: A) {
  a.doSomething()
  a.aProperty = ...
}

在Swift中，动态调度默认情况下是通过一个vtable（虚函数表）间接的调用。如果使用了dynamic关键字来声明，Swift会调用OC发送消息的方法去替代。
这两种情况都要比直接的方法调用慢，因为这样就会阻止除间接调用本身之外的许多编译器的优化。在性能关键的代码中，动态行为会被严格的限制。

建议：当你知道声明以后不会被重写（overridden）的时候，请使用'final'关键字。

final关键字是声明类，方法或者属性上的一个限制，这样声明就不能被重写（overridden）。这就意味着编译器能够直接的调用方法而不是间接的调用。
以下示例中，C.array1,D.array1会直接的读取，而D.array2则就间接的通过vtable来调用。
final class C {
  // No declarations in class 'C' can be overridden.
  var array1: [Int]
  func doSomething() { ... }
}

class D {
  final var array1 [Int] // 'array1' cannot be overridden by a computed property.
  var array2: [Int]      // 'array2' *can* be overridden by a computed property.
}

func usingC(c: C) {
   c.array1[i] = ... // Can directly access C.array without going through dynamic dispatch.
   c.doSomething() = ... // Can directly call C.doSomething without going through virtual dispatch.
}

func usingD(d: D) {
   d.array1[i] = ... // Can directly access D.array1 without going through dynamic dispatch.
   d.array2[i] = ... // Will access D.array2 through dynamic dispatch.
}

建议：当声明时不需要被外部文件访问，请使用关键字‘private’

使用private关键字进行声明，限制了声明文件的可见性。
这个能让编译器有能力甄别出所有其它潜在的覆盖声明。因此，由于以上的声明能让编译器自动地推断出fianl关键字，
并且移除间接方法调用和属性访问。
以下示例，e.doSomething()和f.myPrivateVar，如果在同一个文件类E,F中没有任何覆盖声明，这两个方法将被直接调用。
private class E {
  func doSomething() { ... }
}

class F {
  private var myPrivateVar : Int
}

func usingE(e: E) {
  e.doSomething() // There is no sub class in the file that declares this class.
                  // The compiler can remove virtual calls to doSomething()
                  // and directly call A's doSomething method.
}

func usingF(f: F) -> Int {
  return f.myPrivateVar
}

高效使用容器类
由Swift标准类库提供一个重要特性就是通用容器，Array和Dictionary。下面内容将解释如何高效的使用这些类型。

建议：在Array中使用值类型
在Swift中，类型能被分为两类：值类型（像结构体，枚举，元组）和引用类型（类）。一个关键的区别是在NSArray中不能包含值类型。
因此，当使用值类型时，在Array中，优化器会移除大部分对NSArray的支持从降低其中额外的开销。
此外，相比引用类型，如果值类型仅仅递归的包含引用类型，那么值类型仅仅需要引用计数器。
如果使用了没有引用类型的值类型，在数组内就可以避免额外的retain，release的开销。
// Don't use a class here.
struct PhonebookEntry {
  var name : String
  var number : [Int]
}

var a : [PhonebookEntry]

记住：在大值类型和使用引用类型之间要由权衡。在某些情况下，拷贝和移动大值类型过的消耗要大于移除brigding和retain/release的开销。

建议：当NSArray bridging不必要时，使用ContiguousArray来存储引用类型。
如果你需要个引用类型的数组，数组不需要bridge到NSArray，使用ContiguousArray代替Array:
class C { ... }
var a: ContiguousArray<C> = [C(...), C(...), ..., C(...)]

建议：使用适当的可变代替对象分配。
在Swift的所有标准库容器是值类型，使用COW(copy-on-write)执行拷贝替代了显示拷贝。
很多情况下，编译器省略了不必要的拷贝通过持有容器而不是深拷贝。
只有当容器的引用计数大于1斌切该容器是可变的情况下，才会拷贝底层容器。
下面示例中，当d赋值给c的时候不会发生拷贝，但是当d经历了结构性的改变追加2时，d将会被拷贝并且2也会被追加到d中。
var c: [Int] = [ ... ]
var d = c        // No copy will occur here.
d.append(2)      // A copy *does* occur here.

有时候如果使用者不小心，COW也会引起额外的拷贝。例如，在函数中试图修改可变参数对象，在Swift中，所有的参数都会在调用之前引用＋1，
然后在调用结束之前释放掉。这意味着如下方法所示：
func append_one(a: [Int]) -> [Int] {
  a.append(1)
  return a
}

var a = [1, 2, 3]
a = append_one(a)    // A copy may be occur here.

尽管a版本在被append_one之后���由于赋值没使用有，但是  a也许还是被拷贝了。应该使用inout参数来避免这样的问题。
func append_one_in_place(inout a: [Int]) {
  a.append(1)
}

var a = [1, 2, 3]
append_one_in_place(&a)


未检查操作
Swift在执行普通计算的时候通过检查溢出排除了整型溢出bug。当知道没有内存安全问题这类高效的代码中不适合去检查这类问题。

建议：当你确切的知道溢出不可能发生的时候使用未检测整型计算。

在对性能有严格要求的代码中，如果你认为安全，可以省略对溢出的检查。

a : [Int]
b : [Int]
c : [Int]

// Precondition: for all a[i], b[i]: a[i] + b[i] does not overflow!
for i in 0 ... n {
  c[i] = a[i] &+ b[i]
}


泛型
Swift通过泛型的使用，提供非常强大的抽象机制。Swift编译器发出能对任何T执行的MySwiftFunc<T>方法。生成的代码需要一个方法列表的指针和一个包含T的盒子作为参数。
在MySwiftFun<Int>和MySwiftFun<String>之间任何不同的行为通过传递不同的函数指针和由盒子提供的抽象大小来说明。
下面是泛型实例：
class MySwiftFunc<T> { ... }

MySwiftFunc<Int> X    // Will emit code that works with Int...
MySwiftFunc<String> Y // ... as well as String.

当优化启用时，Swift编译器寻找每一段这样的代码，并且尝试确认在调用时候的具体类型（例如：非泛型类型）。如果泛型的定义对于优化器是可见，并且知道具体类型，
Swift编译器会生成一个特殊类型的特殊泛型方法。这个处理叫做特殊化处理，这样的处理能够避免关联泛型的消耗。
下面是更多的实例：
class MyStack<T> {
  func push(element: T) { ... }
  func pop() -> T { ... }
}

func myAlgorithm(a: [T], length: Int) { ... }

// The compiler can specialize code of MyStack[Int]
var stackOfInts: MyStack[Int]
// Use stack of ints.
for i in ... {
  stack.push(...)
  stack.pop(...)
}

var arrayOfInts: [Int]
// The compiler can emit a specialized version of 'myAlgorithm' targeted for
// [Int]' types.
myAlgorithm(arrayOfInts, arrayOfInts.length)

建议：把泛型的声明放在使用它的文件中
优化器仅能特殊化处理那些当前可见模块中的泛型声明。只有在同一个文件中声明和调用泛型的时候才执行。
注意，标准库是一个特殊的例外。定义在标准库中所有可见模块都能特殊化处理。

建议：允许编译器执行泛型特殊化
只有当调用位置和被调用函数在同一个编译单元中的编译器才会对泛型代码特殊化处理。
我们能够使用一个技巧来让编译器进行被调函数的优化，就是在被调函数所在的同一编译单元中进行类型检查。
执行类型检查后会重新调度这个调用的泛型函数－但是这个时候它就带有类型信息。
在接下来的代码中，我们在方法play_a_game方法中加入了类型检查，并且使运行速度提高了几百倍。
//Framework.swift:

protocol Pingable { func ping() -> Self }
protocol Playable { func play() }

extension Int : Pingable {
  func ping() -> Int { return self + 1 }
}

class Game<T : Pingable> : Playable {
  var t : T

  init (_ v : T) {t = v}

  func play() {
    for _ in 0...100_000_000 { t = t.ping() }
  }
}

func play_a_game(game : Playable ) {
  // This check allows the optimizer to specialize the
  // generic call 'play'
  if let z = game as? Game<Int> {
    z.play()
  } else {
    game.play()
  }
}

/// -------------- >8

// Application.swift:

play_a_game(Game(10))

























